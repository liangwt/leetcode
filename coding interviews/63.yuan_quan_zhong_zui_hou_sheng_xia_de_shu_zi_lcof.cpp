// n = 9 , m = 3

//         v                               被删除的元素   最后存活元素在当前数组的位置
// 0   1   2   3   4   5   6   7   8    --- 2                  0
// 3   4   5   6   7   8   0   1        --- 5                  6
// 6   7   8   0   1   3   4            --- 8                  3
// 0   1   3   4   6   7                --- 3                  0
// 4   6   7   0   1                    --- 7                  3
// 0   1   4   6                        --- 4                  0
// 6   0   1                            --- 1                  1
// 6   0                                --- 6                  0
// 0

// 假设我们已经知道N个人时，胜利者的下标位置为K。那下一轮N-1个人时，胜利者的下标位置为多少？

// 删掉编号为M的人后，之后的人都往前面移动了M位，胜利这也往前移动了M位，所以他的下标位置由k变成K-M。


// 假设我们已经知道N个人时，胜利者的下标位置为K。那上一轮N+1个人时，胜利者的下标位置为多少？

// 这可以看错是上一个问题的逆过程，大家都往后移动M位
// 所以f(N+1,M)=f(N,M)+M。不过有可能数组会越界，所以最后模上当前人数的个数，f(N+1,M)= (f(N,M)+M)%N

#include <vector>

class Solution
{
public:
    int lastRemaining(int n, int m)
    {
        int p = 0;

        for (int i = 2; i <= n; i++)
        {
            p = (p + m) % i;
        }

        return p;
    }
};

int main()
{
    Solution s;

    assert(s.lastRemaining(5, 3) == 3);
    assert(s.lastRemaining(10, 17) == 2);
}